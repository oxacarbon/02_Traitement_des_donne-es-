---
title: "02_Projet_AÃ©rien"
author: "Asta Ouattara"
date: "2025-05-21"
output: pdf_document
editor_options: 
  markdown: 
    wrap: 72
---

# Etape 3 du projet : automatisation des tÃ¢ches

## Travil Ã  faire

CrÃ©ation de fonction et de boucle
 1. Calculateur de retard total par avion
But : Ã‰crire une fonction retard_total(tailnum) qui retourne le retard cumulÃ© pour un avion spÃ©cifique.

CompÃ©tences : group_by, summarise, filter, gestion des NA.

ğŸ‘‰ Bonus : Ajouter une option pour filtrer selon le mois.

ğŸ“… 2. Fonction de planning de vol journalier
But : CrÃ©er une fonction planning_journalier(date) qui affiche tous les vols ce jour-lÃ , triÃ©s par heure de dÃ©part.

EntrÃ©e : une date (ex. "2013-05-17")

Sortie : un data.frame avec les vols.

ğŸ“‰ 3. Analyse comparative entre deux compagnies
But : Fonction compare_carriers(c1, c2) pour comparer la performance (retards moyens, distance, temps de vol, etc.)

Bonus : Retourner aussi des graphiques comparatifs (avec ggplot2).

ğŸŒ 4. Cartographie des trajets ( pas trÃ¨s utile de cartographier les villes)
But : CrÃ©er une fonction trace_routes(carrier) qui trace les principales routes utilisÃ©es par une compagnie sur une carte (ggplot2 + maps ou leaflet).

DonnÃ©es utiles : airports (dans nycflights13)

â± 5. Fonction de performance horaire
But : Fonction perf_par_heure(carrier) pour voir Ã  quelle heure une compagnie a le plus de retards ou dâ€™annulations.

Sortie : un graphique ou un tableau des retards moyens par heure.

ğŸ“Š 6. Score de fiabilitÃ© des vols
But : CrÃ©er une fonction score_fiabilite(carrier) qui donne un score basÃ© sur :

% de vols annulÃ©s

% de vols en retard de plus de 15 min

temps de vol vs distance

Apprentissage : logique conditionnelle, pondÃ©ration de critÃ¨res, visualisation.

ğŸ“¦ 7. Fonction multi-filtre personnalisÃ©e
But : Une fonction filtrer_vols(date = NULL, carrier = NULL, dest = NULL, min_delay = NULL) qui permet de filtrer dynamiquement selon les inputs de l'utilisateur.

CompÃ©tences : arguments optionnels, logique if (!is.null(...)), piping dynamique.

ğŸš¨ 8. DÃ©tection des jours critiques
But : CrÃ©er une fonction jours_critiques(n = 5) qui retourne les jours avec le plus de retards ou dâ€™annulations.

Bonus : Affichage visuel des jours critiques sur un calendrier (avec ggplot2 ou timevis).


## Etape 1 : tÃ©lÃ©charger les donnÃ©es depuis le markdown 02_Projet_AÃ©rien.rmd


```{r}
# Etape 1 : 1. Calculateur de retard total par avion
#But : Ã‰crire une fonction retard_total(tailnum) qui retourne le retard cumulÃ© pour un avion spÃ©cifique.


# DÃ©finition de la fonction
retard_total <- function(tailnum, mois = NULL) {
  # Ã‰tape 1 : filtrer les vols de cet avion
  vols <- flights %>%
    filter(tailnum == !!tailnum, !is.na(arr_delay))

  # Ã‰tape 2 : si mois est spÃ©cifiÃ©, on filtre aussi sur le mois
  if (!is.null(mois)) {
    vols <- vols %>% filter(month == mois)
  }

  # Ã‰tape 3 : calcul du retard cumulÃ©
  total <- sum(vols$arr_delay)

  # Ã‰tape 4 : renvoyer le rÃ©sultat
  return(total)
}


```




## Afficher tout les vols par vol et par heure 
Calcul du retard cumulÃ©

```{r}
planning_journalier <- function(date_str) {
  # Convertir la date en composantes
  date_parts <- strsplit(date_str, "-")[[1]]
  year <- as.numeric(date_parts[1])
  month <- as.numeric(date_parts[2])
  day <- as.numeric(date_parts[3])

  # Filtrer et trier les vols de ce jour
  vols_du_jour <- flights %>%
    filter(year == year, month == month, day == day) %>%
    arrange(hour, minute)

  return(vols_du_jour)
}

# ğŸ§ª Exemple
planning_journalier("2013-06-15")

```

## Analyse comparative pour les deux compagnies 

## Comparaison de deux compagnies en fonction de leur nombre de retard

```{r}
compare_carriers <- function(c1, c2) {
  resume <- flights %>%
    filter(carrier %in% c(c1, c2)) %>%
    group_by(carrier) %>%
    summarise(
      retard_moyen = mean(arr_delay, na.rm = TRUE),
      distance_moyenne = mean(distance, na.rm = TRUE),
      duree_moyenne = mean(air_time, na.rm = TRUE)
    )
  return(resume)
}

# ğŸ§ª Exemple
compare_carriers("AA", "DL")

```


## Construction d'une fonction sur les vols 

```{r}
compare_carriers <- function(c1, c2) {
  resume <- flights %>%
    filter(carrier %in% c(c1, c2)) %>%
    group_by(carrier) %>%
    summarise(
      retard_moyen = mean(arr_delay, na.rm = TRUE),
      distance_moyenne = mean(distance, na.rm = TRUE),
      duree_moyenne = mean(air_time, na.rm = TRUE)
    )
  return(resume)
}

# ğŸ§ª Exemple
compare_carriers("AA", "DL")

```



## Mise en place d'indicateur de notation des compagnies aÃ©riennes 

Objectifs : crÃ©er des scores de fiabilitÃ©s basÃ©es sur les vols annulÃ©s, les vols en retard et les indicateurs efficicatiÃ© distance et temps de vols


6. Fonction score_fiabilite(carrier)
ğŸ¯ Objectif :
Attribuer un score Ã  une compagnie selon :

% de vols annulÃ©s (pas de dep_time)

% de vols en retard de +15 min

EfficacitÃ© distance vs. temps de vol


```{r}
score_fiabilite <- function(carrier_code) {
  # SÃ©lection des vols de la compagnie
  df <- flights %>% filter(carrier == carrier_code)

  total_vols <- nrow(df)
  vols_annules <- sum(is.na(df$dep_time))
  vols_retard_15min <- sum(df$dep_delay > 15, na.rm = TRUE)
  efficacite <- mean(df$distance / df$air_time, na.rm = TRUE)  # miles / minute

  # Scores partiels (pondÃ©rÃ©s sur 100)
  score_annul <- 100 * (1 - vols_annules / total_vols)
  score_retard <- 100 * (1 - vols_retard_15min / total_vols)
  score_effic <- 100 * (efficacite / max(df$distance / df$air_time, na.rm = TRUE))

  # Score global pondÃ©rÃ©
  score_final <- round(0.4 * score_annul + 0.4 * score_retard + 0.2 * score_effic, 2)

  return(data.frame(
    compagnie = carrier_code,
    score_fiabilite = score_final
  ))
}

# ğŸ§ª Exemple
score_fiabilite("AA")

## Interpretation des resulats du score d efiabilitÃ© 

# Score Ã©levÃ© (~85-100) â†’ compagnie fiable
# ğŸ” Score moyen (~60-85) â†’ acceptable, mais amÃ©liorable
# ğŸš© Score faible (<60) â†’ compagnie peu fiable (annulations frÃ©quentes, retards, etc.)



```


## InterpretatilbiltÃ© du score de fiabilitÃ©

ğŸ¯ Objectif : crÃ©er un score de fiabilitÃ© pour une compagnie
On veut savoir : Ã  quel point une compagnie aÃ©rienne est fiable ?
On va crÃ©er un score sur 100 Ã  partir de 3 critÃ¨res :

CritÃ¨re	Pourquoi câ€™est important ?
1. % de vols annulÃ©s	Trop d'annulations = mauvaise fiabilitÃ©
2. % de vols en retard (> 15 min)	Beaucoup de retards = mauvaise ponctualitÃ©
3. EfficacitÃ© distance / durÃ©e	Distance longue pour peu de temps = bon ratio = avion rapide

ğŸ§® Comment on calcule chaque sous-score ?
ğŸŸ© 1. Score dâ€™annulation

score_annul <- 100 * (1 - nb_annulÃ©s / nb_total_vols)

==> InterprÃ©tation :

Si 0% de vols annulÃ©s â†’ score = 100 (parfait)

Si 100% de vols annulÃ©s â†’ score = 0 (catastrophique)


ğŸŸ¨ 2. Score de retard

score_retard <- 100 * (1 - nb_retards_15min / nb_total_vols)

==> InterprÃ©tation :
Si 0% de vols en retard de plus de 15 min â†’ score = 100

Si tous les vols sont en retard â†’ score = 0

ğŸŸ¦ 3. Score dâ€™efficacitÃ© (distance parcourue par minute de vol)

efficacite <- mean(distance / air_time)
score_effic <- 100 * (efficacite / max(efficacite))

==> InterprÃ©tation :
On compare la moyenne Ã  la meilleure compagnie.

Plus câ€™est Ã©levÃ©, mieux câ€™est (lâ€™avion Â« va plus vite Â» sur de longues distances)


âš–ï¸ Score pondÃ©rÃ© final

Tous les critÃ¨res nâ€™ont pas le mÃªme poids :

CritÃ¨re	Poids
Annulations	40 %
Retards	40 %
EfficacitÃ©	20 %


score_final <- 0.4 * score_annul + 0.4 * score_retard + 0.2 * score_effic


ğŸ” Exemple fictif
Imaginons une compagnie avec :

5 % de vols annulÃ©s â†’ score_annul = 100 * (1 - 0.05) = 95

20 % de vols en retard > 15 min â†’ score_retard = 100 * (1 - 0.20) = 80

Moyenne distance/air_time = 7, max = 10 â†’ score_effic = 100 * (7 / 10) = 70

Alors :

score_final = 0.4*95 + 0.4*80 + 0.2*70 = 38 + 32 + 14 = 84
La compagnie aurait un score de fiabilitÃ© de 84/100 ğŸŸ¢

ğŸ” Pourquoi pondÃ©rer ?
Parce quâ€™on veut dire :

"Mieux vaut un vol en retard quâ€™un vol annulÃ©"

"Lâ€™efficacitÃ© est moins critique que la ponctualitÃ©"




## Pourquoi la pondÃ©ration est-elle importante?  (dans notre cas systÃ¨me de nottaion composite)

ğŸ¯ Pourquoi pondÃ©rer ?
PondÃ©rer permet de donner plus dâ€™importance Ã  certains critÃ¨res dans le rÃ©sultat final.
Tous les critÃ¨res nâ€™ont pas le mÃªme impact ni la mÃªme gravitÃ©.

Exemple :
Un vol annulÃ© est plus problÃ©matique quâ€™un vol en retard de 15 minutes.

Donc on accorde plus de poids aux annulations quâ€™aux petits retards.

ğŸ§® D'oÃ¹ viennent les poids ? (0.4, 0.4, 0.2)
Dans notre cas, les poids sont :
CritÃ¨re	Poids choisi	Justification
Annulations	0.4 (40%)	Câ€™est le pire cas (vol supprimÃ©)
Retards > 15 min	0.4 (40%)	GÃªne importante, mais pas critique
EfficacitÃ©	0.2 (20%)	IntÃ©ressant mais secondaire ici

ğŸ‘‰ Ces poids sont choisis manuellement, selon la logique mÃ©tier (expÃ©rience utilisateur, gravitÃ© des cas).

ğŸ§  MÃ©thodes possibles pour fixer les poids
1. ğŸ¯ MÃ©thode experte (comme ici)
Tu relies les poids Ã  lâ€™impact perÃ§u sur la satisfaction client ou la performance.

Câ€™est simple, transparent et utile pour prototyper.

2. ğŸ“Š MÃ©thode statistique (nous le veroons dans le projet 05)
Tu peux faire de la rÃ©gression pour voir quel critÃ¨re explique le mieux la satisfaction, les coÃ»ts, etc.

3. ğŸ“¥ MÃ©thode participative
Tu fais un sondage (ex. auprÃ¨s de voyageurs) : "Quâ€™est-ce qui vous dÃ©range le plus ?"

Tu en dÃ©duis les poids.

4. ğŸ“ˆ Optimisation automatique
Machine learning, techniques de scoring (ex : AHP, PCA pondÃ©rÃ©e, etc.)

ğŸ› ï¸ En rÃ©sumÃ© : pourquoi câ€™est utile de pondÃ©rer ?
Avantage	Explication
ğŸ¯ ReflÃ©ter les prioritÃ©s	Tous les critÃ¨res nâ€™ont pas le mÃªme impact
âš–ï¸ CrÃ©er un score Ã©quilibrÃ©	Tu peux Ã©viter quâ€™un seul bon critÃ¨re masque les autres
ğŸ” Faciliter lâ€™interprÃ©tation	Tu peux dire : â€œCe score est surtout influencÃ© par les retardsâ€
ğŸ”„ Ajustable	Tu peux tester plusieurs scÃ©narios de pondÃ©ration

ğŸ” Et si je ne pondÃ©rais pas ?
Sans pondÃ©ration, chaque critÃ¨re aurait le mÃªme poids (Ã©quivalent Ã  33% chacun ici).
Tu peux trÃ¨s bien tester cela aussi :

==> InterprÃ©tation :
score_final <- mean(c(score_annul, score_retard, score_effic))
Mais ce serait moins prÃ©cis si certains critÃ¨res sont plus pÃ©nalisants que dâ€™autres.



```{r}


```

### CrÃ©ation de fonction pour les plannings des vols

7. Fonction filtrer_vols(date = NULL, carrier = NULL, dest = NULL, min_delay = NULL)
ğŸ¯ Objectif :
Filtrer dynamiquement les vols en fonction de plusieurs critÃ¨res (tous facultatifs).


```{r}
filtrer_vols <- function(date = NULL, carrier = NULL, dest = NULL, min_delay = NULL) {
  df <- flights

  if (!is.null(date)) {
    date_parts <- strsplit(date, "-")[[1]]
    df <- df %>%
      filter(year == as.numeric(date_parts[1]),
             month == as.numeric(date_parts[2]),
             day == as.numeric(date_parts[3]))
  }

  if (!is.null(carrier)) {
    df <- df %>% filter(carrier == carrier)
  }

  if (!is.null(dest)) {
    df <- df %>% filter(dest == dest)
  }

  if (!is.null(min_delay)) {
    df <- df %>% filter(dep_delay >= min_delay)
  }

  return(df)
}

# ğŸ§ª Exemples
filtrer_vols(carrier = "DL", min_delay = 60)
filtrer_vols(date = "2013-07-04", dest = "LAX")

```



## Filtrer en fonction des jours critiques 
8. Fonction jours_critiques(n = 5)
ğŸ¯ Objectif :
Afficher les jours avec le plus de retards et/ou annulations.

```{r}
jours_critiques <- function(n = 5) {
  flights %>%
    mutate(jour = as.Date(time_hour),
           annule = is.na(dep_time)) %>%
    group_by(jour) %>%
    summarise(
      retard_moyen = mean(dep_delay, na.rm = TRUE),
      nb_annules = sum(annule),
      total_vols = n(),
      score_critique = retard_moyen + (nb_annules / total_vols * 100)
    ) %>%
    arrange(desc(score_critique)) %>%
    head(n)
}

# ğŸ§ª Exemple
jours_critiques(10)

```




## IdÃ©e avancÃ©e d'initiation Ã  a programmation 

## Initiation Ã  la programmation 

**IdÃ©e de suggestion 2 pour la partie modÃ©lisation**

creation de fonction et de boucle 1. Calculateur de retard total par
avion But : Ã‰crire une fonction retard_total(tailnum) qui retourne le
retard cumulÃ© pour un avion spÃ©cifique.

CompÃ©tences : group_by, summarise, filter, gestion des NA.

ğŸ‘‰ Bonus : ajouter une option pour filtrer selon le mois.

ğŸ“… 2. Fonction de planning de vol journalier But : CrÃ©er une fonction
planning_journalier(date) qui affiche tous les vols ce jour-lÃ , triÃ©s
par heure de dÃ©part.

EntrÃ©e : une date (ex. "2013-05-17")

Sortie : un data.frame avec les vols.

ğŸ“‰ 3. Analyse comparative entre deux compagnies But : Fonction
compare_carriers(c1, c2) pour comparer la performance (retards moyens,
distance, temps de vol, etc.)

Bonus : Retourner aussi des graphiques comparatifs (avec ggplot2).

ğŸŒ 4. Cartographie des trajets But : CrÃ©er une fonction
trace_routes(carrier) qui trace les principales routes utilisÃ©es par une
compagnie sur une carte (ggplot2 + maps ou leaflet).

DonnÃ©es utiles : airports (dans nycflights13)

â± 5. Fonction de performance horaire But : Fonction
perf_par_heure(carrier) pour voir Ã  quelle heure une compagnie a le plus
de retards ou dâ€™annulations.

Sortie : un graphique ou un tableau des retards moyens par heure.

ğŸ“Š 6. Score de fiabilitÃ© des vols But : CrÃ©er une fonction
score_fiabilite(carrier) qui donne un score basÃ© sur :

\% de vols annulÃ©s

\% de vols en retard de plus de 15 min

temps de vol vs distance

Apprentissage : logique conditionnelle, pondÃ©ration de critÃ¨res,
visualisation.

ğŸ“¦ 7. Fonction multi-filtre personnalisÃ©e But : Une fonction
filtrer_vols(date = NULL, carrier = NULL, dest = NULL, min_delay = NULL)
qui permet de filtrer dynamiquement selon les inputs de l'utilisateur.

CompÃ©tences : arguments optionnels, logique if (!is.null(...)), piping
dynamique.

ğŸš¨ 8. DÃ©tection des jours critiques But : CrÃ©er une fonction
jours_critiques(n = 5) qui retourne les jours avec le plus de retards ou
dâ€™annulations.

Bonus : Affichage visuel des jours critiques sur un calendrier (avec
ggplot2 ou timevis).

